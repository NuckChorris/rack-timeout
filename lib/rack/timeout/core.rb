require 'securerandom'
require_relative 'support/monotonic_time'
require_relative 'support/scheduler'
require_relative 'support/timeout'
require_relative 'legacy'

module Rack
  class Timeout
    include Rack::Timeout::MonotonicTime # gets us the #fsecs method

    RequestDetails = Struct.new(
      :id,      # a unique identifier for the request. informative-only.
      :service, # time rack spent processing the request (updated every second)
      :timeout, # the actual computed timeout to be used for this request
      :state,   # the request's current state, see VALID_STATES below
    ) do
      def ms(k) # helper method used for formatting values in milliseconds
        '%.fms' % (self[k] * 1000) if self[k]
      end
    end
    VALID_STATES = %i[ready active timed_out completed].freeze
    # Key where our RequestDetails instance is stored in rack env
    ENV_INFO_KEY = 'rack-timeout.info'.freeze
    # Key where request id is stored if generated by load balancer
    HTTP_X_REQUEST_ID = 'HTTP_X_REQUEST_ID'.freeze
    # Key where request id is stored if generated by ActionDispatch
    ACTION_DISPATCH_REQUEST_ID = 'action_dispatch.request_id'.freeze

    # Helper to read timeout properties, validating them.
    def read_timeout_property(value, default)
      case value
      when nil then default
      when false then false
      when 0 then false
      else
        unless value.is_a?(Numeric) && value.positive?
          raise ArgumentError, "value #{value.inspect} should be false, zero, or
                                positive".squish
        end
        value
      end
    end

    # How long the application can take to complete handling the request once
    # it's passed down to it.
    attr_reader :service_timeout

    def initialize(app, service_timeout: nil)
      @service_timeout = read_timeout_property service_timeout, 15
      @app = app
    end

    RT = self # shorthand reference
    def call(env)
      Raven.rack_context(env)
      # Generate our RequestDetails
      info = (env[ENV_INFO_KEY] ||= RequestDetails.new)
      # Set the request ID
      info.id ||= env[HTTP_X_REQUEST_ID] ||
                  env[ACTION_DISPATCH_REQUEST_ID] ||
                  SecureRandom.uuid

      # The monotonic time the request started being processed by rack
      ts_started_service = fsecs

      # pass request through if service_timeout is false
      return @app.call(env) unless service_timeout

      # Mark request as ready
      RT._set_state!(env, :ready)

      heartbeat_event = nil
      # Runs every second to update status and track time
      register_state_change = ->(status = :active) do
        # Cancel heartbeats if the request stops being active
        heartbeat_event.cancel! if status != :active
        # Update service time
        info.service = fsecs - ts_started_service
        # Update status
        RT._set_state!(env, status)
      end
      # Start updating ever ysecond while active
      heartbeat_event = RT::Scheduler.run_every(1) do
        register_state_change.call(:active)
      end

      # Create a Timeout instance to handle timing out the request.  If the
      # request times out, the block is run.
      timeout = RT::Scheduler::Timeout.new do |app_thread|
        register_state_change.call(:timed_out)
        req = ::Rack::Request.new(env)
        # Send it to Sentry
        Raven.capture_message(
          'Request Timed Out',
          fingerprint: [
            'Rack::Timeout',
            req.request_method,
            req.script_name
          ].map(&:to_s),
          level: :error,
          backtrace: app_thread.backtrace
        )
      end

      # Run request w/ timeout
      timeout.timeout(service_timeout) do
        # Send request down the middleware chain
        begin @app.call(env)
        ensure register_state_change.call(:completed)
        end
      end
    end

    def self._set_state!(env, state)
      raise "Invalid state: #{state.inspect}" unless VALID_STATES.include? state
      env[ENV_INFO_KEY].state = state
      notify_state_change_observers(env)
    end

    ### state change notification-related methods
    @state_change_observers = {}

    # Registers a block to be called back when a request changes state in
    # rack-timeout. The block will receive the request's env.
    #
    # `id` is anything that uniquely identifies this particular callback, mostly
    # so it may be removed via `unregister_state_change_observer`.
    def self.register_state_change_observer(id, &callback)
      raise ArgumentError, 'A callback block is required.' unless callback
      @state_change_observers[id] = callback
    end

    # Removes the observer with the given id
    def self.unregister_state_change_observer(id)
      @state_change_observers.delete(id)
    end

    # Sends out the notifications. Called internally at the end of `_set_state!`
    def self.notify_state_change_observers(env)
      @state_change_observers.values.each { |observer| observer.call(env) }
    end
  end
end
